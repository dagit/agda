------------------------------------------------------------------------
-- Release notes for Agda 2 version 2.2.10
------------------------------------------------------------------------

Important changes since 2.2.8:

Language
--------

* The flag --without-K makes pattern matching more restricted. If the
  flag is activated, then Agda only accepts certain case-splits: if
  the type of the variable to be split is D pars ixs, where D is a
  data (or record) type, pars stands for the parameters, and ixs the
  indices, then the following requirements must be satisfied:

  * The indices ixs must be applications of constructors to distinct
    variables.

  * These variables must not be free in pars.

  The intended use of --without-K is to enable experiments with a
  propositional equality without the K rule. Let us define propositional
  equality as follows:

    data _≡_ {A : Set} : A → A → Set where
      refl : ∀ x → x ≡ x

  Then the obvious implementation of the J rule is accepted:

    J : {A : Set} (P : {x y : A} → x ≡ y → Set) →
        (∀ x → P (refl x)) →
        ∀ {x y} (x≡y : x ≡ y) → P x≡y
    J P p (refl x) = p x

  The same applies to Christine Paulin-Mohring's version of the J rule:

    J′ : {A : Set} {x : A} (P : {y : A} → x ≡ y → Set) →
         P (refl x) →
         ∀ {y} (x≡y : x ≡ y) → P x≡y
    J′ P p (refl x) = p

  On the other hand, the obvious implementation of the K rule is not
  accepted:

    K : {A : Set} (P : {x : A} → x ≡ x → Set) →
        (∀ x → P (refl x)) →
        ∀ {x} (x≡x : x ≡ x) → P x≡x
    K P p (refl x) = p x

  However, we have /not/ proved that activation of --without-K ensures
  that the K rule cannot be proved in some other way.

* Irrelevant declarations.

  Prefixing the type signature of a postulate or a function marks
  this identifier as irrelevant which means it can only be refered
  to in irrelevant positions or in other irrelevant declarations.

    postulate
      .irrelevant : {A : Set} → .A → A

  This axiom can be used for instance to define a projection from
  an irrelevant record field.

    data Subset (A : Set) (P : A → Set) : Set where
      _#_ : (elem : A) → .(P elem) → Subset A P

    .certificate : ∀ {A P} → (x : Subset A P) → P (elem x)
    certificate (a # p) = irrelevant p

  Right to = we are in relevant position, so we cannot directly put p
  there.  However, since certificate is declared irrelevant, it can
  use other irrelevant declarations, in particular the axiom irrelevant,
  whose argument p is now in irrelevant position.

  The above axiom justifies irrelevant projections, hence for record
  defintitions like

    record Subset (A : Set) (P : A → Set) : Set where
      constructor _#_
      field
        elem : A
        .certificate : P elem

  they are generated automatically, unless the option

    --no-irrelevant-projections

  is supplied.  Irrelevant projections are highly experimental.

* Termination checker recognizes projections.

  Projections now preserve sizes, both in patterns and expressions.
  Example:

    record Wrap (A : Set) : Set where
      constructor wrap
      field
        unwrap : A

    open Wrap public

    data WNat : Set where
      zero : WNat
      suc  : Wrap WNat → WNat

    id : WNat → WNat
    id zero    = zero
    id (suc w) = suc (wrap (id (unwrap w)))

  In the structural ordering unwrap w ≤ w. This means that

    unwrap w ≤ w < suc w,

  and hence the recursive call to id is accepted.

  Projections also preserve guardedness.

Tools
-----

* Most occurrences of record field names are now highlighted as
  "fields". Previously many occurrences were highlighted as
  "functions".

* Emacs mode: It is no longer possible to change the behaviour of the
  TAB key by customising agda2-indentation.

* Epic compiler backend.

  A new backend for Agda to compile to Epic has been created. Epic is a language
  used by Idris and Epigram made by Edwin Brady. Almost all of Agda should work
  when using this backend, but it needs more testing. It should be noted that
  this is very much experimental code.

  There is a new pragma for giving the Epic code for postulated definitions.
  The Epic code given can then contain the definition itself, or use a foreign
  call to call a C function. The pragma is {-# COMPILED_EPIC def code #-} and
  works similar to the COMPILED pragma but instead of expecting Haskell code,
  it expects Epic code. The code includes function arguments, return
  type and the function body. Note that def is the name of an Agda definition,
  which will be translated to a valid Epic name automatically.

  The Epic backend supports Agda's primitive pragma for primitive functions that
  are defined (with the same name) in the AgdaPrelude.e
  (Agda/src/data/EpicInclude/) file.

  Usage:
  > agda --epic --epic-flag=<EPIC-FLAG> --compile-dir=<DIR> <FILE>.agda

  A new directory, Epic, will be created in the compile-dir (default: the
  project root), containing the file main.e with the Epic source code. The
  compiler will also do a system call running the Epic compiler on that file,
  passing any epic-flags to Epic in the order of their appearance.

  The compilation requires a definition of main, which should be of type IO Unit.
  Currently IO A actions are represented in Epic as functions from Unit to A.
  Because of this the main function is applied a single unit.

  Here follows how to define the IO monad:
    postulate
      IO : Set → Set
      return  : ∀ {A} → A → IO A
      _>>=_   : ∀ {A B} → IO A → (A → IO B) → IO B

    {-# COMPILED_EPIC return (u1 : Unit, a : Any) -> Any = ioreturn(a) #-}
    {-# COMPILED_EPIC _>>=_ (u1 : Unit, u2 : Unit, x : Any, f : Any) -> Any = iobind(x,f) #-}

  ioreturn and iobind are Epic functions defined in AgdaPrelude.e which is
  always included. This is how IO is defined in the standard library
  (IO.Primitive). We only need to add the new COMPILED_EPIC pragmas.

  The backend supports the {-# BUILTIN #-} pragma, which can be used e.g. to get
  Natural numbers and their operations to be represented more efficiently as
  BigInts and operations on them in Epic.

  By default the backend will remove forced constructor arguments. Pattern matching
  on forced variables will be rewritten so that it doesn't use the forced variable.
  This optmization can be disabled by using the flag --no-forcing.

  All types that looks like Nats after forced constructor arguments have been
  removed - i.e. if they have two constructors: one with no arguments and one
  with a recursive argument - will be represented as BigInts. This applies to
  the standard Fin type for example.

  Compilation using Epic requires a few libraries. Particularly gcc, the Boehm
  garbage collector and the GNU MP library. For more information, check out
  Epic's homepage: http://www.cs.st-andrews.ac.uk/~eb/epic.php

Tools
-----

* Hyperlinks for top-level module names now point to the start of the
  module rather than to the declaration of the module name. This
  applies both to the Emacs mode and to the output of agda --html.
