------------------------------------------------------------------------
-- Release notes for Agda 2 version 2.2.8
------------------------------------------------------------------------

Important changes since 2.2.6:

Language
--------

* Record pattern matching.

  It is now possible to pattern match on named record constructors.
  However, if you want to make use of η-equality you still need to use
  projection functions.

  Example:

    record Σ (A : Set) (B : A → Set) : Set where
      constructor _,_
      field
        proj₁ : A
        proj₂ : B proj₁

    map : {A B : Set} {P : A → Set} {Q : B → Set}
          (f : A → B) → (∀ {x} → P x → Q (f x)) →
          Σ A P → Σ B Q
    map f g (x , y) = (f x , g y)

* Injective type constructors off by default.

  Automatic injectivity of type constructors has been disabled (by
  default). To enable it, use the flag --injective-type-constructors,
  either on the command line or in an OPTIONS pragma. Note that this
  flag makes Agda anti-classical and possibly inconsistent:

    Agda with excluded middle is inconsistent
    http://thread.gmane.org/gmane.comp.lang.agda/1367

  See test/succeed/InjectiveTypeConstructors.agda for an example.

* Infinite types.

  If the new flag --guardedness-preserving-type-constructors is used,
  then type constructors are treated as inductive constructors when we
  check productivity (but only in parameters, and only if they are
  used strictly positively or not at all). This makes examples such as
  the following possible:

    data Rec (A : ∞ Set) : Set where
      fold : ♭ A → Rec A

    ℕ : Set
    ℕ = ⊤ ⊎ Rec (♯ ℕ)

    zero : ℕ
    zero = inj₁ _

    suc : ℕ → ℕ
    suc n = inj₂ (fold n)

    ℕ-rec : (P : ℕ → Set) →
            P zero →
            (∀ n → P n → P (suc n)) →
            ∀ n → P n
    ℕ-rec P z s (inj₁ _)        = z
    ℕ-rec P z s (inj₂ (fold n)) = s n (ℕ-rec P z s n)

  Note that this feature is experimental, it is not known if it leads
  to inconsistencies. It seems to be rather strong: if the
  productivity checker were smarter, then we could encode
  induction-recursion using it.

* Qualified constructors.

  Constructors can now be referred to qualified by their data type.
  For instance, given

    data Nat : Set where
      zero : Nat
      suc  : Nat → Nat

    data Fin : Nat → Set where
      zero : ∀ {n} → Fin (suc n)
      suc  : ∀ {n} → Fin n → Fin (suc n)

  you can refer to the constructors unambiguously as Nat.zero,
  Nat.suc, Fin.zero, and Fin.suc. For example:

    inj : (n m : Nat) → Nat.suc n ≡ suc m → n ≡ m
    inj .m m refl = refl

  Previously you had to write

    inj : (n m : Nat) → _≡_ {Nat} (suc n) (suc m) → n ≡ m

  to make the type checker able to figure out that you wanted the
  natural number suc in this case.

* Reflection.

  There are two new constructs for reflection:

    - quoteGoal x in e

      In e the value of x will be a representation of the goal type
      (the type expected of the whole expression) as an element in a
      datatype of Agda terms (see below). For instance,

      example : Nat
      example = quoteGoal x in {! at this point x = def (quote Nat) [] !}

    - quote x : QName

      If x is the name of a definition (function, datatype, record, or
      a constructor), quote x gives you the representation of x as a
      value in the primitive type QName (see below).

  Quoted terms use the following BUILTINs and primitives:

    -- The type of Agda names.
    postulate QName : Set
    {-# BUILTIN QNAME QName #-}
    primitive primQNameEquality : QName → QName → Bool

    Hiding = Bool
    data Arg A : Set where
      arg : Hiding → A → Arg A

    {-# BUILTIN ARG Arg #-}
    {-# BUILTIN ARGARG arg #-}

    -- The type of Agda terms.
    data Term : Set where
      var     : Nat → List (Arg Term) → Term
      con     : QName → List (Arg Term) → Term
      def     : QName → List (Arg Term) → Term
      lam     : Hiding → Term → Term
      pi      : Arg Term → Term → Term
      sort    : Term
      unknown : Term

    {-# BUILTIN AGDATERM            Term    #-}
    {-# BUILTIN AGDATERMVAR         var     #-}
    {-# BUILTIN AGDATERMCON         con     #-}
    {-# BUILTIN AGDATERMDEF         def     #-}
    {-# BUILTIN AGDATERMLAM         lam     #-}
    {-# BUILTIN AGDATERMPI          pi      #-}
    {-# BUILTIN AGDATERMSORT        sort    #-}
    {-# BUILTIN AGDATERMUNSUPPORTED unknown #-}

  Reflection is particularly useful when working with internal
  decision procedures, such as the ring solver in the standard
  library.

Tools
-----

* Show module contents command.

  Given a module name M the Emacs mode can now display all the
  top-level modules and names inside M, along with types for the
  names. The command is activated using C-c C-o or the menus.

* Auto command.

  A command searching for type inhabitants has been added. The
  command is invoked by pressing C-C C-a. There are several flags
  and parameters, e.g. '-c' which enables case-splitting in the
  search. For further information, read section 'Auto' on the
  Agda wiki.
