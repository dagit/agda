------------------------------------------------------------------------
-- Release notes for Agda 2 version 2.2.8
------------------------------------------------------------------------

Important changes since 2.2.6:

Language
--------

* It is now possible to pattern match on named record constructors.
  However, if you want to make use of η-equality you still need to use
  projection functions.

  Example:

    record Σ (A : Set) (B : A → Set) : Set where
      constructor _,_
      field
        proj₁ : A
        proj₂ : B proj₁

    map : {A B : Set} {P : A → Set} {Q : B → Set}
          (f : A → B) → (∀ {x} → P x → Q (f x)) →
          Σ A P → Σ B Q
    map f g (x , y) = (f x , g y)

* Automatic injectivity of type constructors has been disabled (by
  default). To enable it, use the flag --injective-type-constructors,
  either on the command line or in an OPTIONS pragma. Note that this
  flag makes Agda anti-classical and possibly inconsistent:

    Agda with excluded middle is inconsistent
    http://thread.gmane.org/gmane.comp.lang.agda/1367

  See test/succeed/InjectiveTypeConstructors.agda for an example.

* If the new flag --guardedness-preserving-type-constructors is used,
  then type constructors are treated as inductive constructors when we
  check productivity. This makes examples such as the following
  possible:

    data Rec (A : ∞ Set) : Set where
      fold : ♭ A → Rec A

    ℕ : Set
    ℕ = ⊤ ⊎ Rec (♯ ℕ)

    zero : ℕ
    zero = inj₁ _

    suc : ℕ → ℕ
    suc n = inj₂ (fold n)

    ℕ-rec : (P : ℕ → Set) →
            P zero →
            (∀ n → P n → P (suc n)) →
            ∀ n → P n
    ℕ-rec P z s (inj₁ _)        = z
    ℕ-rec P z s (inj₂ (fold n)) = s n (ℕ-rec P z s n)

* Qualified constructors.

  Constructors can now be refered to qualified by their datatype.
  For instance, given

    data Nat : Set where
      zero : Nat
      suc  : Nat → Nat

    data Fin : Nat → Set where
      zero : ∀ {n} → Fin (suc n)
      suc  : ∀ {n} → Fin n → Fin (suc n)

  you can refer to the constructors unambiguously as Nat.zero,
  Nat.suc, Fin.zero, and Fin.suc. For example:

    inj : (n m : Nat) → Nat.suc n ≡ suc m → n ≡ m
    inj .m m refl = refl

  Previously you had to write 

    inj : (n m : Nat) → _≡_ {Nat} (suc n) (suc m) → n ≡ m

  to make the type checker able to figure out that you wanted the
  natural number suc in this case.

Tools
-----

* Command which shows module contents: Given a module name M the Emacs
  mode can now display all the top-level modules and names inside M,
  along with types for the names. The command is activated using
  C-c C-o or the menus.
