------------------------------------------------------------------------
-- Release notes for Agda 2 version 2.2.8
------------------------------------------------------------------------

Important changes since 2.2.6:

Language
--------

* Record pattern matching.

  It is now possible to pattern match on named record constructors.
  However, if you want to make use of η-equality you still need to use
  projection functions.

  Example:

    record Σ (A : Set) (B : A → Set) : Set where
      constructor _,_
      field
        proj₁ : A
        proj₂ : B proj₁

    map : {A B : Set} {P : A → Set} {Q : B → Set}
          (f : A → B) → (∀ {x} → P x → Q (f x)) →
          Σ A P → Σ B Q
    map f g (x , y) = (f x , g y)

* Injective type constructors off by default.

  Automatic injectivity of type constructors has been disabled (by
  default). To enable it, use the flag --injective-type-constructors,
  either on the command line or in an OPTIONS pragma. Note that this
  flag makes Agda anti-classical and possibly inconsistent:

    Agda with excluded middle is inconsistent
    http://thread.gmane.org/gmane.comp.lang.agda/1367

  See test/succeed/InjectiveTypeConstructors.agda for an example.

* Termination checker can count.

  There is a new flag --termination-depth=N accepting values N >= 1
  (with N = 1 being the default) which influences the behavior of the
  termination checker.  So far, the termination checker has only
  distinguished three cases when comparing the argument of a recursive
  call with the formal parameter of the callee.

    < : the argument is structurally smaller than the parameter
    = : they are equal
    ? : the argument is bigger or unrelated to the parameter

  This behavior, which is still the default (N = 1), will not
  recognize the following functions as terminating.  

    mutual
  
      f : ℕ → ℕ
      f zero          = zero
      f (suc zero)    = zero
      f (suc (suc n)) = aux n 
  
      aux : ℕ → ℕ
      aux m = f (suc m)

   The call graph

    f --(<)--> aux --(?)--> f

  yields a recursive call from f to f via aux where the relation of
  call argument to callee parameter is computed as "unrelated"
  (composition of < and ?).

  Setting N >= 2 allows a finer analysis: n has two constructors less
  than (suc (suc n)), and (suc m) has one more than m, so we get the
  call graph:

    f --(-2)--> aux --(+1)--> f

  The indirect call f --> f is now labeled with (-1), the termination
  checker can now recognize that the call argument is decreasing on
  this path.

  Setting termination depth to N means that the termination checker
  counts decrease up to N and increase up to N-1.  The default, N=1,
  means that no increase is counted, every increase turns to
  "unrelated".

  In practice, the above example often arises when we use "with",
  e.g., the program

    f : ℕ → ℕ
    f zero          = zero
    f (suc zero)    = zero
    f (suc (suc n)) with zero
    ... | _ = f (suc n)
  
  is internally represented as
  
    mutual
  
      f : ℕ → ℕ
      f zero          = zero
      f (suc zero)    = zero
      f (suc (suc n)) = aux n zero
  
      aux : ℕ → ℕ → ℕ
      aux m k = f (suc m)

  Thus, by default, the definition of f via "with" is not accepted by
  the termination checker, against appearance ((suc) n is a subterm of
  (suc (suc n))). Now, the termination checker is satisfied with
  option "--termination-depth=2".

  Caveats:

  - This is an experimental feature, hopefully being replaced by
    something smarter in the near future.

  - Increasing the termination depth will quickly lead to very long
    termination checking times.  So, use with care.  Setting
    termination depth to 100 by habit, just to be on the safe side, is
    not a good idea!

  - Increasing termination depths makes only sense for linear data
    types such as ℕ and Size.  For other types, increase cannot be
    recognized.  For instance, consider a similar example with lists.

      data List : Set where
	nil  : List
	cons : ℕ → List → List

      mutual
	f : List → List
	f nil                  = nil
	f (cons x nil)         = nil
	f (cons x (cons y ys)) = aux y ys

	aux : ℕ → List → List 
	aux z zs = f (cons z zs)

    Here, the termination checker compares (cons z zs) to z and also
    to zs.  In both cases, the result will be "unrelated", no matter
    how high we set the termination depth.  This is because when
    comparing (cons z zs) to zs, for instance, z is unrelated to zs,
    thus, (cons z zs) is also unrelated to zs.  We cannot say it is
    just one up since z could a very large term.  Anyway, this points
    to a weakness of untyped termination checking and could be fixed
    by switching to a type-based termination checker.

    To regain the benefit of an increased termination depth, we need
    to index our lists by a linear type such as ℕ or Size.  With
    termination depth 2, the above example is accepted for vectors
    instead of lists.

* Infinite types.

  If the new flag --guardedness-preserving-type-constructors is used,
  then type constructors are treated as inductive constructors when we
  check productivity (but only in parameters, and only if they are
  used strictly positively or not at all). This makes examples such as
  the following possible:

    data Rec (A : ∞ Set) : Set where
      fold : ♭ A → Rec A

    ℕ : Set
    ℕ = ⊤ ⊎ Rec (♯ ℕ)

    zero : ℕ
    zero = inj₁ _

    suc : ℕ → ℕ
    suc n = inj₂ (fold n)

    ℕ-rec : (P : ℕ → Set) →
            P zero →
            (∀ n → P n → P (suc n)) →
            ∀ n → P n
    ℕ-rec P z s (inj₁ _)        = z
    ℕ-rec P z s (inj₂ (fold n)) = s n (ℕ-rec P z s n)

  Note that this feature is experimental, it is not known if it leads
  to inconsistencies. It seems to be rather strong: if the
  productivity checker were smarter, then we could encode
  induction-recursion using it.

* Qualified constructors.

  Constructors can now be referred to qualified by their data type.
  For instance, given

    data Nat : Set where
      zero : Nat
      suc  : Nat → Nat

    data Fin : Nat → Set where
      zero : ∀ {n} → Fin (suc n)
      suc  : ∀ {n} → Fin n → Fin (suc n)

  you can refer to the constructors unambiguously as Nat.zero,
  Nat.suc, Fin.zero, and Fin.suc. For example:

    inj : (n m : Nat) → Nat.suc n ≡ suc m → n ≡ m
    inj .m m refl = refl

  Previously you had to write

    inj : (n m : Nat) → _≡_ {Nat} (suc n) (suc m) → n ≡ m

  to make the type checker able to figure out that you wanted the
  natural number suc in this case.

* Reflection.

  There are two new constructs for reflection:

    - quoteGoal x in e

      In e the value of x will be a representation of the goal type
      (the type expected of the whole expression) as an element in a
      datatype of Agda terms (see below). For instance,

      example : Nat
      example = quoteGoal x in {! at this point x = def (quote Nat) [] !}

    - quote x : QName

      If x is the name of a definition (function, datatype, record, or
      a constructor), quote x gives you the representation of x as a
      value in the primitive type QName (see below).

  Quoted terms use the following BUILTINs and primitives:

    -- The type of Agda names.
    postulate QName : Set
    {-# BUILTIN QNAME QName #-}
    primitive primQNameEquality : QName → QName → Bool

    Hiding = Bool
    data Arg A : Set where
      arg : Hiding → A → Arg A

    {-# BUILTIN ARG Arg #-}
    {-# BUILTIN ARGARG arg #-}

    -- The type of Agda terms.
    data Term : Set where
      var     : Nat → List (Arg Term) → Term
      con     : QName → List (Arg Term) → Term
      def     : QName → List (Arg Term) → Term
      lam     : Hiding → Term → Term
      pi      : Arg Term → Term → Term
      sort    : Term
      unknown : Term

    {-# BUILTIN AGDATERM            Term    #-}
    {-# BUILTIN AGDATERMVAR         var     #-}
    {-# BUILTIN AGDATERMCON         con     #-}
    {-# BUILTIN AGDATERMDEF         def     #-}
    {-# BUILTIN AGDATERMLAM         lam     #-}
    {-# BUILTIN AGDATERMPI          pi      #-}
    {-# BUILTIN AGDATERMSORT        sort    #-}
    {-# BUILTIN AGDATERMUNSUPPORTED unknown #-}

  Reflection is particularly useful when working with internal
  decision procedures, such as the ring solver in the standard
  library.

Tools
-----

* Show module contents command.

  Given a module name M the Emacs mode can now display all the
  top-level modules and names inside M, along with types for the
  names. The command is activated using C-c C-o or the menus.

* Auto command.

  A command searching for type inhabitants has been added. The
  command is invoked by pressing C-C C-a. There are several flags
  and parameters, e.g. '-c' which enables case-splitting in the
  search. For further information, read section 'Auto' on the
  Agda wiki.
