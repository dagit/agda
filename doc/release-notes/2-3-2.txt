------------------------------------------------------------------------
-- Release notes for Agda 2 version 2.3.2
------------------------------------------------------------------------

Important changes since 2.3.0:

Installation
============

* The Agda-executable package has been removed.

  The executable is now provided as part of the Agda package.

* The Emacs mode no longer depends on haskell-mode or GHCi.

Pragmas and Options
===================

* The --without-K check now reconstructs constructor parameters.

  New specification of --without-K:

  If the flag is activated, then Agda only accepts certain
  case-splits. If the type of the variable to be split is D pars ixs,
  where D is a data (or record) type, pars stands for the parameters,
  and ixs the indices, then the following requirements must be
  satisfied:

  * The indices ixs must be applications of constructors (or literals)
    to distinct variables. Constructors are usually not applied to
    parameters, but for the purposes of this check constructor
    parameters are treated as other arguments.

  * These distinct variables must not be free in pars.

* Irrelevant arguments are printed as _ by default now.  To turn on
  printing of irrelevant arguments, use option

    --show-irrelevant

* New: Pragma NO_TERMINATION_CHECK to switch off termination checker
  for individual function definitions and mutual blocks.

  The pragma must precede a function definition or a mutual block.
  Examples (see test/succeed/NoTerminationCheck.agda):

  1. Skipping a single definition: before type signature.

       {-# NO_TERMINATION_CHECK #-}
       a : A
       a = a

  2. Skipping a single definition: before first clause.

       b : A
       {-# NO_TERMINATION_CHECK #-}
       b = b

  3. Skipping an old-style mutual block: Before 'mutual' keyword.

       {-# NO_TERMINATION_CHECK #-}
       mutual
         c : A
         c = d

         d : A
         d = c

  4. Skipping a new-style mutual block: Anywhere before a type
     signature or first function clause in the block

       i : A
       j : A

       i = j
       {-# NO_TERMINATION_CHECK #-}
       j = i

  The pragma cannot be used in --safe mode.

Language
========

* Let binding record patterns

    record _×_ (A B : Set) : Set where
      constructor _,_
      field
        fst : A
        snd : B
    open _×_

    let (x , (y , z)) = t
    in  u

  will now be interpreted as

    let x = fst t
        y = fst (snd t)
        z = snd (snd t)
    in  u

  Note that the type of t needs to be inferable.  If you need to provide
  a type signature, you can write the following:

    let a : ...
        a = t
        (x , (y , z)) = a
    in  u

* Pattern synonyms

  A pattern synonym is a declaration that can be used on the left hand
  side (when pattern matching) as well as the right hand side (in
  expressions). For example:

  pattern z    = zero
  pattern ss x = suc (suc x)

  f : ℕ -> ℕ
  f z       = z
  f (suc z) = ss z
  f (ss n)  = n

  Pattern synonyms are implemented by substitution on the abstract
  syntax, so definitions are scope-checked but not type-checked. They
  are particularly useful for universe constructions.

* Qualified mixfix operators

  It is now possible to use a qualified mixfix operator by qualifying the first
  part of the name. For instance

    import Data.Nat as Nat
    import Data.Bool as Bool

    two = Bool.if true then 1 Nat.+ 1 else 0

Type checking
=============

* Instance arguments resolution will now consider candidates which
  still need expect arguments. For example:

    record Eq (A : Set) : Set where
      field eq : A → A → Bool

    open Eq {{...}}

    eqFin : {n : ℕ} → Eq (Fin n)
    eqFin = record { eq = primEqFin }

    testFin : Bool
    testFin = eq fin1 fin2

  The type-checker will now resolve the instance argument of the eq
  function to eqFin {_}. This is only done for implicit arguments, not
  instance arguments, so that the instance search stays non-recursive.

* Constraint solving: Upgraded Miller patterns to record patterns. [Issue 456]

  Agda now solves meta-variables that are applied to record patterns.
  A typical (but here, artificial) case is:

    record Sigma (A : Set)(B : A -> Set) : Set where
      constructor _,_
      field
        fst : A
        snd : B fst

    test : (A : Set)(B : A -> Set) ->
      let X : Sigma A B -> Sigma A B
          X = _
      in  (x : A)(y : B x) -> X (x , y) ≡ (x , y)
    test A B x y = refl

  This yields a constraint of the form

    _X A B (x , y) := t[x,y]

  (with t[x,y] = (x, y)) which is not a Miller pattern.
  However, Agda now solves this as

    _X A B z := t[fst z,snd z].

* Changed: solving recursive constraints.  [Issue 585]

  Until 2.3.0, Agda sometimes inferred values that did not pass the
  termination checker later, or would even make Agda loop.  To prevent this,
  the occurs check now also looks into the definitions of the current mutual
  block, to avoid constructing recursive solutions.  As a consequence, also
  terminating recursive solutions are no longer found automatically.

  This effects a programming pattern where the recursively computed
  type of a recursive function is left to Agda to solve.

    mutual

      T : D -> Set
      T pattern1 = _
      T pattern2 = _

      f : (d : D) -> T d
      f pattern1 = rhs1
      f pattern2 = rhs2

  This might no longer work from now on.
  See examples test/fail/Issue585*.agda

Compiler backends
=================

Tools
=====

Emacs mode
----------

* Asynchronous Emacs mode.

  One can now use Emacs while a buffer is type-checked. If the buffer
  is edited while the type-checker runs, then syntax highlighting will
  not be updated when type-checking is complete.

* Interactive syntax highlighting.

  The syntax highlighting is updated while a buffer is type-checked:

  • At first the buffer is highlighted in a somewhat crude way
    (without go-to-definition information for overloaded
    constructors).

  • If the highlighting level is "interactive", then the piece of code
    that is currently being type-checked is highlighted as such. (The
    default is "non-interactive".)

  • When a mutual block has been type-checked it is highlighted
    properly (this highlighting includes warnings for potential
    non-termination).

  The highlighting level can be controlled via the new configuration
  variable agda2-highlight-level.

* The Emacs mode now presents information about which module is
  currently being type-checked.

* New global menu entry: Information about the character at point.

  If this entry is selected, then information about the character at
  point is displayed, including (in many cases) information about how
  to type the character.

* Commenting/uncommenting the rest of the buffer.

  One can now comment or uncomment the rest of the buffer by typing
  C-c C-x M-; or by selecting the menu entry "Comment/uncomment the
  rest of the buffer".

* The Emacs mode now uses the Agda executable instead of GHCi.

  A new configuration variable has been introduced:
  agda2-program-name, the name of the Agda executable (by default
  agda).

  The variable agda2-ghci-options has been replaced by
  agda2-program-args: extra arguments given to the Agda executable (by
  default none).

  If you want to limit Agda's memory consumption you can add some
  arguments to agda2-program-args, for instance +RTS -M1.5G -RTS.

* The Emacs mode no longer depends on haskell-mode.

  Users who have customised certain haskell-mode variables (such as
  haskell-ghci-program-args) may want to update their configuration.
